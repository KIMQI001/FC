	单机多worker：numsealworker=5   	constants.rs
问题：是否与POST_SECTORS_COUNT参数有关系

    	"autoSealIntervalSeconds": 30	config.json
问题：是否与共识机制有关
		// schedules sealing of staged piece-data
	if node.Repo.Config().Mining.AutoSealIntervalSeconds > 0 {

多机多worker：
	version 1.0 (单机存储多机调用)
	1.单拆proof
	2.远程调用->sectorStore->sectorManager->stagedAccess_sealedAccess->write_and_preprocess
        写成一个httpServer，暴露sectorMannager和seal的接口，远程调用seal函数，返回结果给主节点

	seal的流程：sb中调用seal_internal->proof中的seal





所有和扇区交互的都放在rs里边，在go层接收到文件放在/tmp文件下，.fifo结尾。
在rs层，通过SectorManager生成一个setorAccess文件,进行数据写入和密封。

addPiece:manager生成一个stagingAccess,去写
seal:manager拿出staged_sector.sector_access.clone(),生成一个sealedAccess

所有交互底层在proofs-rust-fil-sb-sb-src-helpers/

最底层和硬盘交互在 disk_backed_storage.rs

rest full


// 扇区信息总管
SectorMetadataManager{
	kv_store,
	state,
	seal_input_tx,
	scheduler_input_tx: scheduler_input_tx.clone(),
	max_num_staged_sectors,
	max_user_bytes_per_staged_sector,
	secotrStore{

		StagedSectorMetadata {
			pieces: Default::default(),	{<Vec>pieceMeta{      piece_key,
				   					 num_bytes: piece_bytes_len,}}
			sector_access: access.clone(),
			sector_id,
			seal_status: SealStatus::Pending,
		    }
	}
	
}



SectorBuilderState {
                    prover_id,
                    staged: StagedState {
                        sector_id_nonce: last_committed_sector_id,
                        sectors: Default::default(),
                    },
                    sealed: Default::default(),
                }



pub struct SectorBuilder {

    sealers_tx: mpsc::Sender<SealerInput>,						    // Prevents FFI consumers from queueing behind long-running seal operations.

    
    sealers: Vec<SealerWorker>,								// For additional seal concurrency, add more workers here.


    scheduler_tx: mpsc::SyncSender<Request>,						    // The main worker's queue.


    scheduler: Scheduler,								    // The main worker. Owns all mutable state for the SectorBuilder.


    sector_class: SectorClass,								    // Configures size of proofs and sectors managed by the SectorBuilder.
}




Node.initSectorBuilderForNode->	cfg := sectorbuilder.RustSectorBuilderConfig{		//node.go
		BlockService:     node.blockservice,
		LastUsedSectorID: lastUsedSectorID,
		MetadataDir:      stagingDir,								//TODO: 现在我们让stagingDir来存储自己的metadata，metadata应该有自己的文件夹的
		MinerAddr:        minerAddr,
		SealedSectorDir:  sealedDir,
		StagedSectorDir:  stagingDir,								// node.Repo.Config().SectorBase.RootDir
		SectorClass:      types.NewSectorClass(sectorSize),
	}

	sb, err := sectorbuilder.NewRustSectorBuilder(cfg){				//node.go->rustsectorbuilder.go->C.h

		C.sector_builder_ffi_init_sector_builder(				//C.h->api.rs
			class,
			C.uint64_t(cfg.LastUsedSectorID),
			cMetadataDir,
			(*[31]C.uint8_t)(proverIDCBytes),
			cSealedSectorDir,
			cStagedSectorDir,								// cStagedSectorDir := C.CString(cfg.StagedSectorDir)
			C.uint8_t(MaxNumStagedSectors),
		){
			SectorBuilder::init_from_metadata(				//api.rs->builder.rs
			from_ffi_sector_class(sector_class),
			last_used_sector_id,
			c_str_to_rust_str(metadata_dir).to_string(),
			*prover_id,
			c_str_to_rust_str(sealed_sector_dir).to_string(),
			c_str_to_rust_str(staged_sector_dir).to_string(),
			max_num_staged_sectors,
		    ){
				let kv_store = Arc::new(WrappedKeyValueStore {
				    inner: Box::new(SledKvs::initialize(metadata_dir.into())?),
				})
			        let sector_store = Arc::new(new_sector_store(		//bulider.rs->disk_backed_storage.rs
				    sector_class,
				    sealed_sector_dir.into(),
				    staged_sector_dir.into(),
				)){
					ConcreteSectorStore {										// 创建一个sectorStore
					    let manager = Box::new(DiskManager {
						staging_path,
						sealed_path,
					    })	
						impl SectorManager for DiskManager {							// 根据DiskManger实现一个sectorManager
						    fn new_staging_sector_access(&self) -> Result<String, SectorManagerErr> {		// 在staging_path创建一个staging_sector_access
							self.new_sector_access(Path::new(&self.staging_path)){				// 根据path创建一个sector_access
							let pbuf = root.join(util::rand_alpha_string(32));				// 创建一个32位的随机字符串
								create_dir_all(root)							// 创建secotr的文件夹
								    .map_err(|err| SectorManagerErr::ReceiverError(format!("{:?}", err)))
								    .and_then(|_| {
									File::create(&pbuf)						// 生成的以上边32位随机字符串命名的文件
									    .map(|_| 0)							
							}
						    fn write_and_preprocess(								// Addpiece
							&self,
							access: &str,
							data: &mut dyn Read,
						    ) -> Result<UnpaddedBytesAmount, SectorManagerErr> {
							OpenOptions::new()
							    .read(true)
							    .write(true)
							    .open(access)								// 打开access
							    .map_err(|err| SectorManagerErr::CallerError(format!("{:?}", err)))
							    .and_then(|mut file| {
											//disk_backed_storage.rs->fr32.rs
								write_padded(data, &mut file)						// 将data写入sector_access
								    .map_err(|err| SectorManagerErr::ReceiverError(format!("{:?}", err)))
								    .map(|n| UnpaddedBytesAmount(n as u64))
							    })
						    }


					    let sector_config = Box::new(Config::from(sector_class));
					    let proofs_config = Box::new(Config::from(sector_class));

					    ConcreteSectorStore {
						proofs_config,
						sector_config,
						manager,
					    }
					}
					}
			}

		}	

	}
// 结论：在node调用initSector的时候，经过逐层传参，new_sector_access的时候用的是node调用initSector时用的sbConfig里边的参数。

new_sector_access生成一个以32位随机数字符串命名的一个空sector

seal的逻辑：从sectorBuilder的seal.rs调用seal，seal实现在filecoin-proofs的api，将staged_access的内容复制到sealed_access,然后打开sealed_access将里边的数据map给data，然后给data进行zigzag

sealResults上链逻辑:node.go 的StartMining开启协程死循环：result := <-node.SectorBuilder().SectorSealResults(): ,Rusults由Rusult信道而来，Rusult由poller更新，pollor的meta信息由findSealedSectorMetadata而来，findSealedSectorMetadata 中的response包含所需SealedSectorMetadata，response由sector_builder_ffi_GetSealStatusResponse而来，sector_builder_ffi_GetSealStatusResponse由sector_builder_ffi_get_seal_status而来



